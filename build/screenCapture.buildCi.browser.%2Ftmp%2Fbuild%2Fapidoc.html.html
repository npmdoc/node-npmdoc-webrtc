<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/henrikjoreteg/webrtc.js">webrtc (v1.14.1)</a>
</h1>
<h4>WebRTC abstraction for making it simple to manage multiple peer connections of various types.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.webrtc">module webrtc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.webrtc">
            function <span class="apidocSignatureSpan"></span>webrtc
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer">
            function <span class="apidocSignatureSpan">webrtc.</span>peer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_">
            function <span class="apidocSignatureSpan">webrtc.</span>super_
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.super_">
            function <span class="apidocSignatureSpan">webrtc.</span>super_.super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webrtc.</span>peer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webrtc.</span>super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webrtc.</span>super_.super_.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webrtc.peer">module webrtc.peer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer.peer">
            function <span class="apidocSignatureSpan">webrtc.</span>peer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer.super_">
            function <span class="apidocSignatureSpan">webrtc.peer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webrtc.peer.prototype">module webrtc.peer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer.prototype._observeDataChannel">
            function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>_observeDataChannel
            <span class="apidocSignatureSpan">(channel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer.prototype.end">
            function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer.prototype.getDataChannel">
            function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>getDataChannel
            <span class="apidocSignatureSpan">(name, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer.prototype.handleDataChannelAdded">
            function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>handleDataChannelAdded
            <span class="apidocSignatureSpan">(channel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer.prototype.handleMessage">
            function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>handleMessage
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer.prototype.handleRemoteStreamAdded">
            function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>handleRemoteStreamAdded
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer.prototype.handleStreamRemoved">
            function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>handleStreamRemoved
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer.prototype.icerestart">
            function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>icerestart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer.prototype.onIceCandidate">
            function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>onIceCandidate
            <span class="apidocSignatureSpan">(candidate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer.prototype.send">
            function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>send
            <span class="apidocSignatureSpan">(messageType, payload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer.prototype.sendDirectly">
            function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>sendDirectly
            <span class="apidocSignatureSpan">(channel, messageType, payload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer.prototype.sendFile">
            function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>sendFile
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.peer.prototype.start">
            function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webrtc.super_">module webrtc.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.super_">
            function <span class="apidocSignatureSpan">webrtc.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webrtc.super_.prototype">module webrtc.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype._audioEnabled">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>_audioEnabled
            <span class="apidocSignatureSpan">(bool)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype._videoEnabled">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>_videoEnabled
            <span class="apidocSignatureSpan">(bool)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.isAudioEnabled">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>isAudioEnabled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.isVideoEnabled">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>isVideoEnabled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.mute">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>mute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.pause">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.pauseVideo">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>pauseVideo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.resume">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.resumeVideo">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>resumeVideo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.setMicIfEnabled">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>setMicIfEnabled
            <span class="apidocSignatureSpan">(volume)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.setupAudioMonitor">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>setupAudioMonitor
            <span class="apidocSignatureSpan">(stream, harkOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.start">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>start
            <span class="apidocSignatureSpan">(mediaConstraints, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.startLocalMedia">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>startLocalMedia
            <span class="apidocSignatureSpan">(mediaConstraints, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.startScreenShare">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>startScreenShare
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.stop">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>stop
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.stopLocalMedia">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>stopLocalMedia
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.stopScreenShare">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>stopScreenShare
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.stopStreams">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>stopStreams
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.prototype.unmute">
            function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>unmute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webrtc.super_.super_">module webrtc.super_.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.super_.super_">
            function <span class="apidocSignatureSpan">webrtc.super_.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.super_.mixin">
            function <span class="apidocSignatureSpan">webrtc.super_.super_.</span>mixin
            <span class="apidocSignatureSpan">(constructor)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webrtc.super_.super_.prototype">module webrtc.super_.super_.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">webrtc.super_.super_.prototype.</span>isWildEmitter</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.super_.prototype.emit">
            function <span class="apidocSignatureSpan">webrtc.super_.super_.prototype.</span>emit
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.super_.prototype.getWildcardCallbacks">
            function <span class="apidocSignatureSpan">webrtc.super_.super_.prototype.</span>getWildcardCallbacks
            <span class="apidocSignatureSpan">(eventName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.super_.prototype.off">
            function <span class="apidocSignatureSpan">webrtc.super_.super_.prototype.</span>off
            <span class="apidocSignatureSpan">(event, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.super_.prototype.on">
            function <span class="apidocSignatureSpan">webrtc.super_.super_.prototype.</span>on
            <span class="apidocSignatureSpan">(event, groupName, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.super_.prototype.once">
            function <span class="apidocSignatureSpan">webrtc.super_.super_.prototype.</span>once
            <span class="apidocSignatureSpan">(event, groupName, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webrtc.super_.super_.prototype.releaseGroup">
            function <span class="apidocSignatureSpan">webrtc.super_.super_.prototype.</span>releaseGroup
            <span class="apidocSignatureSpan">(groupName)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webrtc" id="apidoc.module.webrtc">module webrtc</a></h1>


    <h2>
        <a href="#apidoc.element.webrtc.webrtc" id="apidoc.element.webrtc.webrtc">
        function <span class="apidocSignatureSpan"></span>webrtc
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebRTC(opts) {
    var self = this;
    var options = opts || {};
    var config = this.config = {
            debug: false,
            // makes the entire PC config overridable
            peerConnectionConfig: {
                iceServers: [{"url": "stun:stun.l.google.com:19302"}]
            },
            peerConnectionConstraints: {
                optional: [
                    {DtlsSrtpKeyAgreement: true}
                ]
            },
            receiveMedia: {
                mandatory: {
                    OfferToReceiveAudio: true,
                    OfferToReceiveVideo: true
                }
            },
            enableDataChannels: true
        };
    var item;

    // expose screensharing check
    this.screenSharingSupport = webrtc.screenSharing;

    // We also allow a 'logger' option. It can be any object that implements
    // log, warn, and error methods.
    // We log nothing by default, following "the rule of silence":
    // http://www.linfo.org/rule_of_silence.html
    this.logger = function () {
        // we assume that if you're in debug mode and you didn't
        // pass in a logger, you actually want to log as much as
        // possible.
        if (opts.debug) {
            return opts.logger || console;
        } else {
        // or we'll use your logger which should have its own logic
        // for output. Or we'll return the no-op.
            return opts.logger || mockconsole;
        }
    }();

    // set options
    for (item in options) {
        this.config[item] = options[item];
    }

    // check for support
    if (!webrtc.support) {
        this.logger.error('Your browser doesn\'t seem to support WebRTC');
    }

    // where we'll store our peer connections
    this.peers = [];

    // call localMedia constructor
    localMedia.call(this, this.config);

    this.on('speaking', function () {
        if (!self.hardMuted) {
            // FIXME: should use sendDirectlyToAll, but currently has different semantics wrt payload
            self.peers.forEach(function (peer) {
                if (peer.enableDataChannels) {
                    var dc = peer.getDataChannel('hark');
                    if (dc.readyState != 'open') return;
                    dc.send(JSON.stringify({type: 'speaking'}));
                }
            });
        }
    });
    this.on('stoppedSpeaking', function () {
        if (!self.hardMuted) {
            // FIXME: should use sendDirectlyToAll, but currently has different semantics wrt payload
            self.peers.forEach(function (peer) {
                if (peer.enableDataChannels) {
                    var dc = peer.getDataChannel('hark');
                    if (dc.readyState != 'open') return;
                    dc.send(JSON.stringify({type: 'stoppedSpeaking'}));
                }
            });
        }
    });
    this.on('volumeChange', function (volume, treshold) {
        if (!self.hardMuted) {
            // FIXME: should use sendDirectlyToAll, but currently has different semantics wrt payload
            self.peers.forEach(function (peer) {
                if (peer.enableDataChannels) {
                    var dc = peer.getDataChannel('hark');
                    if (dc.readyState != 'open') return;
                    dc.send(JSON.stringify({type: 'volume', volume: volume }));
                }
            });
        }
    });

    // log events in debug mode
    if (this.config.debug) {
        this.on('*', function (event, val1, val2) {
            var logger;
            // if you didn't pass in a logger and you explicitly turning on debug
            // we're just going to assume you're wanting log output with console
            if (self.config.logger === mockconsole) {
                logger = console;
            } else {
                logger = self.logger;
            }
            logger.log('event:', event, val1, val2);
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.peer" id="apidoc.element.webrtc.peer">
        function <span class="apidocSignatureSpan">webrtc.</span>peer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Peer(options) {
    var self = this;

    this.id = options.id;
    this.parent = options.parent;
    this.type = options.type || 'video';
    this.oneway = options.oneway || false;
    this.sharemyscreen = options.sharemyscreen || false;
    this.browserPrefix = options.prefix;
    this.stream = options.stream;
    this.enableDataChannels = options.enableDataChannels === undefined ? this.parent.config.enableDataChannels : options.enableDataChannels
;
    this.receiveMedia = options.receiveMedia || this.parent.config.receiveMedia;
    this.channels = {};
    this.sid = options.sid || Date.now().toString();
    // Create an RTCPeerConnection via the polyfill
    this.pc = new PeerConnection(this.parent.config.peerConnectionConfig, this.parent.config.peerConnectionConstraints);
    this.pc.on('ice', this.onIceCandidate.bind(this));
    this.pc.on('offer', function (offer) {
        self.send('offer', offer);
    });
    this.pc.on('answer', function (offer) {
        self.send('answer', offer);
    });
    this.pc.on('addStream', this.handleRemoteStreamAdded.bind(this));
    this.pc.on('addChannel', this.handleDataChannelAdded.bind(this));
    this.pc.on('removeStream', this.handleStreamRemoved.bind(this));
    // Just fire negotiation needed events for now
    // When browser re-negotiation handling seems to work
    // we can use this as the trigger for starting the offer/answer process
    // automatically. We'll just leave it be for now while this stabalizes.
    this.pc.on('negotiationNeeded', this.emit.bind(this, 'negotiationNeeded'));
    this.pc.on('iceConnectionStateChange', this.emit.bind(this, 'iceConnectionStateChange'));
    this.pc.on('iceConnectionStateChange', function () {
        switch (self.pc.iceConnectionState) {
        case 'failed':
            // currently, in chrome only the initiator goes to failed
            // so we need to signal this to the peer
            if (self.pc.pc.peerconnection.localDescription.type === 'offer') {
                self.parent.emit('iceFailed', self);
                self.send('connectivityError');
            }
            break;
        }
    });
    this.pc.on('signalingStateChange', this.emit.bind(this, 'signalingStateChange'));
    this.logger = this.parent.logger;

    // handle screensharing/broadcast mode
    if (options.type === 'screen') {
        if (this.parent.localScreen &amp;&amp; this.sharemyscreen) {
            this.logger.log('adding local screen stream to peer connection');
            this.pc.addStream(this.parent.localScreen);
            this.broadcaster = options.broadcaster;
        }
    } else {
        this.parent.localStreams.forEach(function (stream) {
            self.pc.addStream(stream);
        });
    }

    // call emitter constructor
    WildEmitter.call(this);

    this.on('channelOpen', function (channel) {
        if (channel.protocol === INBAND_FILETRANSFER_V1) {
            channel.onmessage = function (event) {
                var metadata = JSON.parse(event.data);
                var receiver = new FileTransfer.Receiver();
                receiver.receive(metadata, channel);
                self.emit('fileTransfer', metadata, receiver);
                receiver.on('receivedFile', function (file, metadata) {
                    receiver.channel.close();
                });
            };
        }
    });

    // proxy events to parent
    this.on('*', function () {
        self.parent.emit.apply(self.parent, arguments);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_" id="apidoc.element.webrtc.super_">
        function <span class="apidocSignatureSpan">webrtc.</span>super_
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LocalMedia(opts) {
    WildEmitter.call(this);

    var config = this.config = {
        autoAdjustMic: false,
        detectSpeakingEvents: false,
        audioFallback: false,
        media: {
            audio: true,
            video: true
        },
        logger: mockconsole
    };

    var item;
    for (item in opts) {
        this.config[item] = opts[item];
    }

    this.logger = config.logger;
    this._log = this.logger.log.bind(this.logger, 'LocalMedia:');
    this._logerror = this.logger.error.bind(this.logger, 'LocalMedia:');

    this.screenSharingSupport = webrtcSupport.screenSharing;

    this.localStreams = [];
    this.localScreens = [];

    if (!webrtcSupport.supportGetUserMedia) {
        this._logerror('Your browser does not support local media capture.');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.super_" id="apidoc.element.webrtc.super_.super_">
        function <span class="apidocSignatureSpan">webrtc.</span>super_.super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WildEmitter() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webrtc.peer" id="apidoc.module.webrtc.peer">module webrtc.peer</a></h1>


    <h2>
        <a href="#apidoc.element.webrtc.peer.peer" id="apidoc.element.webrtc.peer.peer">
        function <span class="apidocSignatureSpan">webrtc.</span>peer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Peer(options) {
    var self = this;

    this.id = options.id;
    this.parent = options.parent;
    this.type = options.type || 'video';
    this.oneway = options.oneway || false;
    this.sharemyscreen = options.sharemyscreen || false;
    this.browserPrefix = options.prefix;
    this.stream = options.stream;
    this.enableDataChannels = options.enableDataChannels === undefined ? this.parent.config.enableDataChannels : options.enableDataChannels
;
    this.receiveMedia = options.receiveMedia || this.parent.config.receiveMedia;
    this.channels = {};
    this.sid = options.sid || Date.now().toString();
    // Create an RTCPeerConnection via the polyfill
    this.pc = new PeerConnection(this.parent.config.peerConnectionConfig, this.parent.config.peerConnectionConstraints);
    this.pc.on('ice', this.onIceCandidate.bind(this));
    this.pc.on('offer', function (offer) {
        self.send('offer', offer);
    });
    this.pc.on('answer', function (offer) {
        self.send('answer', offer);
    });
    this.pc.on('addStream', this.handleRemoteStreamAdded.bind(this));
    this.pc.on('addChannel', this.handleDataChannelAdded.bind(this));
    this.pc.on('removeStream', this.handleStreamRemoved.bind(this));
    // Just fire negotiation needed events for now
    // When browser re-negotiation handling seems to work
    // we can use this as the trigger for starting the offer/answer process
    // automatically. We'll just leave it be for now while this stabalizes.
    this.pc.on('negotiationNeeded', this.emit.bind(this, 'negotiationNeeded'));
    this.pc.on('iceConnectionStateChange', this.emit.bind(this, 'iceConnectionStateChange'));
    this.pc.on('iceConnectionStateChange', function () {
        switch (self.pc.iceConnectionState) {
        case 'failed':
            // currently, in chrome only the initiator goes to failed
            // so we need to signal this to the peer
            if (self.pc.pc.peerconnection.localDescription.type === 'offer') {
                self.parent.emit('iceFailed', self);
                self.send('connectivityError');
            }
            break;
        }
    });
    this.pc.on('signalingStateChange', this.emit.bind(this, 'signalingStateChange'));
    this.logger = this.parent.logger;

    // handle screensharing/broadcast mode
    if (options.type === 'screen') {
        if (this.parent.localScreen &amp;&amp; this.sharemyscreen) {
            this.logger.log('adding local screen stream to peer connection');
            this.pc.addStream(this.parent.localScreen);
            this.broadcaster = options.broadcaster;
        }
    } else {
        this.parent.localStreams.forEach(function (stream) {
            self.pc.addStream(stream);
        });
    }

    // call emitter constructor
    WildEmitter.call(this);

    this.on('channelOpen', function (channel) {
        if (channel.protocol === INBAND_FILETRANSFER_V1) {
            channel.onmessage = function (event) {
                var metadata = JSON.parse(event.data);
                var receiver = new FileTransfer.Receiver();
                receiver.receive(metadata, channel);
                self.emit('fileTransfer', metadata, receiver);
                receiver.on('receivedFile', function (file, metadata) {
                    receiver.channel.close();
                });
            };
        }
    });

    // proxy events to parent
    this.on('*', function () {
        self.parent.emit.apply(self.parent, arguments);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.peer.super_" id="apidoc.element.webrtc.peer.super_">
        function <span class="apidocSignatureSpan">webrtc.peer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WildEmitter() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webrtc.peer.prototype" id="apidoc.module.webrtc.peer.prototype">module webrtc.peer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webrtc.peer.prototype._observeDataChannel" id="apidoc.element.webrtc.peer.prototype._observeDataChannel">
        function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>_observeDataChannel
        <span class="apidocSignatureSpan">(channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_observeDataChannel = function (channel) {
    var self = this;
    channel.onclose = this.emit.bind(this, 'channelClose', channel);
    channel.onerror = this.emit.bind(this, 'channelError', channel);
    channel.onmessage = function (event) {
        self.emit('channelMessage', self, channel.label, JSON.parse(event.data), channel, event);
    };
    channel.onopen = this.emit.bind(this, 'channelOpen', channel);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Peer.prototype.getDataChannel = function (name, opts) {
if (!webrtc.supportDataChannel) return this.emit('error', new Error('createDataChannel not supported'));
var channel = this.channels[name];
opts || (opts = {});
if (channel) return channel;
// if we don't have one by this label, create it
channel = this.channels[name] = this.pc.createDataChannel(name, opts);
this.<span class="apidocCodeKeywordSpan">_observeDataChannel</span>(channel);
return channel;
};

Peer.prototype.onIceCandidate = function (candidate) {
if (this.closed) return;
if (candidate) {
    this.send('candidate', candidate);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.peer.prototype.end" id="apidoc.element.webrtc.peer.prototype.end">
        function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
    if (this.closed) return;
    this.pc.close();
    this.handleStreamRemoved();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.stream) {
    this.logger.warn('Already have a remote stream');
} else {
    this.stream = event.stream;
    // FIXME: addEventListener('ended', ...) would be nicer
    // but does not work in firefox
    this.stream.onended = function () {
        self.<span class="apidocCodeKeywordSpan">end</span>();
    };
    this.parent.emit('peerStreamAdded', this);
}
};

Peer.prototype.handleStreamRemoved = function () {
this.parent.peers.splice(this.parent.peers.indexOf(this), 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.peer.prototype.getDataChannel" id="apidoc.element.webrtc.peer.prototype.getDataChannel">
        function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>getDataChannel
        <span class="apidocSignatureSpan">(name, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataChannel = function (name, opts) {
    if (!webrtc.supportDataChannel) return this.emit('error', new Error('createDataChannel not supported'));
    var channel = this.channels[name];
    opts || (opts = {});
    if (channel) return channel;
    // if we don't have one by this label, create it
    channel = this.channels[name] = this.pc.createDataChannel(name, opts);
    this._observeDataChannel(channel);
    return channel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// returns true when message was sent and false if channel is not open
Peer.prototype.sendDirectly = function (channel, messageType, payload) {
    var message = {
        type: messageType,
        payload: payload
    };
    this.logger.log('sending via datachannel', channel, messageType, message);
    var dc = this.<span class="apidocCodeKeywordSpan">getDataChannel</span>(channel);
    if (dc.readyState != 'open') return false;
    dc.send(JSON.stringify(message));
    return true;
};

// Internal method registering handlers for a data channel and emitting events on the peer
Peer.prototype._observeDataChannel = function (channel) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.peer.prototype.handleDataChannelAdded" id="apidoc.element.webrtc.peer.prototype.handleDataChannelAdded">
        function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>handleDataChannelAdded
        <span class="apidocSignatureSpan">(channel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleDataChannelAdded = function (channel) {
    this.channels[channel.label] = channel;
    this._observeDataChannel(channel);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.peer.prototype.handleMessage" id="apidoc.element.webrtc.peer.prototype.handleMessage">
        function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>handleMessage
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleMessage = function (message) {
    var self = this;

    this.logger.log('getting', message.type, message);

    if (message.prefix) this.browserPrefix = message.prefix;

    if (message.type === 'offer') {
        // workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=1064247
        message.payload.sdp = message.payload.sdp.replace('a=fmtp:0 profile-level-id=0x42e00c;packetization-mode=1\r\n', '');
        this.pc.handleOffer(message.payload, function (err) {
            if (err) {
                return;
            }
            // auto-accept
            self.pc.answer(self.receiveMedia, function (err, sessionDescription) {
                //self.send('answer', sessionDescription);
            });
        });
    } else if (message.type === 'answer') {
        this.pc.handleAnswer(message.payload);
    } else if (message.type === 'candidate') {
        this.pc.processIce(message.payload);
    } else if (message.type === 'connectivityError') {
        this.parent.emit('connectivityError', self);
    } else if (message.type === 'mute') {
        this.parent.emit('mute', {id: message.from, name: message.payload.name});
    } else if (message.type === 'unmute') {
        this.parent.emit('unmute', {id: message.from, name: message.payload.name});
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
test('basic test with two peers', function (t) {
var webrtc1 = new WebRTC({});
var webrtc2 = new WebRTC({});
var peer1;
var peer2;

webrtc1.on('message', function (payload) {
    peer2.<span class="apidocCodeKeywordSpan">handleMessage</span>(payload);
});
webrtc2.on('message', function (payload) {
    peer1.handleMessage(payload);
});
webrtc1.startLocalMedia(null, function (err, stream) {
    if (err) {
        t.fail('failed to get local media');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.peer.prototype.handleRemoteStreamAdded" id="apidoc.element.webrtc.peer.prototype.handleRemoteStreamAdded">
        function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>handleRemoteStreamAdded
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleRemoteStreamAdded = function (event) {
    var self = this;
    if (this.stream) {
        this.logger.warn('Already have a remote stream');
    } else {
        this.stream = event.stream;
        // FIXME: addEventListener('ended', ...) would be nicer
        // but does not work in firefox
        this.stream.onended = function () {
            self.end();
        };
        this.parent.emit('peerStreamAdded', this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.peer.prototype.handleStreamRemoved" id="apidoc.element.webrtc.peer.prototype.handleStreamRemoved">
        function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>handleStreamRemoved
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleStreamRemoved = function () {
    this.parent.peers.splice(this.parent.peers.indexOf(this), 1);
    this.closed = true;
    this.parent.emit('peerStreamRemoved', this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
constraints.mandatory.IceRestart = true;
this.pc.offer(constraints, function (err, success) { });
};

Peer.prototype.end = function () {
if (this.closed) return;
this.pc.close();
this.<span class="apidocCodeKeywordSpan">handleStreamRemoved</span>();
};

Peer.prototype.handleRemoteStreamAdded = function (event) {
var self = this;
if (this.stream) {
    this.logger.warn('Already have a remote stream');
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.peer.prototype.icerestart" id="apidoc.element.webrtc.peer.prototype.icerestart">
        function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>icerestart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">icerestart = function () {
    var constraints = this.receiveMedia;
    constraints.mandatory.IceRestart = true;
    this.pc.offer(constraints, function (err, success) { });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.peer.prototype.onIceCandidate" id="apidoc.element.webrtc.peer.prototype.onIceCandidate">
        function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>onIceCandidate
        <span class="apidocSignatureSpan">(candidate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onIceCandidate = function (candidate) {
    if (this.closed) return;
    if (candidate) {
        this.send('candidate', candidate);
    } else {
        this.logger.log("End of candidates.");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.peer.prototype.send" id="apidoc.element.webrtc.peer.prototype.send">
        function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>send
        <span class="apidocSignatureSpan">(messageType, payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (messageType, payload) {
    var message = {
        to: this.id,
        sid: this.sid,
        broadcaster: this.broadcaster,
        roomType: this.type,
        type: messageType,
        payload: payload,
        prefix: webrtc.prefix
    };
    this.logger.log('sending', messageType, message);
    this.parent.emit('message', message);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.receiveMedia = options.receiveMedia || this.parent.config.receiveMedia;
this.channels = {};
this.sid = options.sid || Date.now().toString();
// Create an RTCPeerConnection via the polyfill
this.pc = new PeerConnection(this.parent.config.peerConnectionConfig, this.parent.config.peerConnectionConstraints);
this.pc.on('ice', this.onIceCandidate.bind(this));
this.pc.on('offer', function (offer) {
    self.<span class="apidocCodeKeywordSpan">send</span>('offer', offer);
});
this.pc.on('answer', function (offer) {
    self.send('answer', offer);
});
this.pc.on('addStream', this.handleRemoteStreamAdded.bind(this));
this.pc.on('addChannel', this.handleDataChannelAdded.bind(this));
this.pc.on('removeStream', this.handleStreamRemoved.bind(this));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.peer.prototype.sendDirectly" id="apidoc.element.webrtc.peer.prototype.sendDirectly">
        function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>sendDirectly
        <span class="apidocSignatureSpan">(channel, messageType, payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendDirectly = function (channel, messageType, payload) {
    var message = {
        type: messageType,
        payload: payload
    };
    this.logger.log('sending via datachannel', channel, messageType, message);
    var dc = this.getDataChannel(channel);
    if (dc.readyState != 'open') return false;
    dc.send(JSON.stringify(message));
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// sends message to all using a datachannel
// only sends to anyone who has an open datachannel
WebRTC.prototype.sendDirectlyToAll = function (channel, message, payload) {
    this.peers.forEach(function (peer) {
        if (peer.enableDataChannels) {
            peer.<span class="apidocCodeKeywordSpan">sendDirectly</span>(channel, message, payload);
        }
    });
};

module.exports = WebRTC;

},{"./peer":3,"localmedia":7,"mockconsole":6,"util":2,"webrtcsupport":5,"
wildemitter":4}],2:[function(require,module,exports){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.peer.prototype.sendFile" id="apidoc.element.webrtc.peer.prototype.sendFile">
        function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>sendFile
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendFile = function (file) {
    var sender = new FileTransfer.Sender();
    var dc = this.getDataChannel('filetransfer' + (new Date()).getTime(), {
        protocol: INBAND_FILETRANSFER_V1
    });
    // override onopen
    dc.onopen = function () {
        dc.send(JSON.stringify({
            size: file.size,
            name: file.name
        }));
        sender.send(file, dc);
    };
    // override onclose
    dc.onclose = function () {
        console.log('sender received transfer');
        sender.emit('complete');
    };
    return sender;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.peer.prototype.start" id="apidoc.element.webrtc.peer.prototype.start">
        function <span class="apidocSignatureSpan">webrtc.peer.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function () {
    var self = this;

    // well, the webrtc api requires that we either
    // a) create a datachannel a priori
    // b) do a renegotiation later to add the SCTP m-line
    // Let's do (a) first...
    if (this.enableDataChannels) {
        this.getDataChannel('simplewebrtc');
    }

    this.pc.offer(this.receiveMedia, function (err, sessionDescription) {
        //self.send('offer', sessionDescription);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        peer1.pc.on('iceConnectionStateChange', function () {
            if (peer1.pc.iceConnectionState == 'connected') {
                t.pass('P2P connection established');
                t.end();
            }
        });

        peer1.<span class="apidocCodeKeywordSpan">start</span>();
    });
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webrtc.super_" id="apidoc.module.webrtc.super_">module webrtc.super_</a></h1>


    <h2>
        <a href="#apidoc.element.webrtc.super_.super_" id="apidoc.element.webrtc.super_.super_">
        function <span class="apidocSignatureSpan">webrtc.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WildEmitter() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webrtc.super_.prototype" id="apidoc.module.webrtc.super_.prototype">module webrtc.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype._audioEnabled" id="apidoc.element.webrtc.super_.prototype._audioEnabled">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>_audioEnabled
        <span class="apidocSignatureSpan">(bool)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_audioEnabled = function (bool) {
    // work around for chrome 27 bug where disabling tracks
    // doesn't seem to work (works in canary, remove when working)
    this.setMicIfEnabled(bool ? 1 : 0);
    this.localStreams.forEach(function (stream) {
        stream.getAudioTracks().forEach(function (track) {
            track.enabled = !!bool;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
    this.localScreens = [];
}
};

// Audio controls
LocalMedia.prototype.mute = function () {
this.<span class="apidocCodeKeywordSpan">_audioEnabled</span>(false);
this.hardMuted = true;
this.emit('audioOff');
};

LocalMedia.prototype.unmute = function () {
this._audioEnabled(true);
this.hardMuted = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype._videoEnabled" id="apidoc.element.webrtc.super_.prototype._videoEnabled">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>_videoEnabled
        <span class="apidocSignatureSpan">(bool)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_videoEnabled = function (bool) {
    this.localStreams.forEach(function (stream) {
        stream.getVideoTracks().forEach(function (track) {
            track.enabled = !!bool;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return;
    }
    this.gainController.setGain(volume);
};

// Video controls
LocalMedia.prototype.pauseVideo = function () {
    this.<span class="apidocCodeKeywordSpan">_videoEnabled</span>(false);
    this.emit('videoOff');
};
LocalMedia.prototype.resumeVideo = function () {
    this._videoEnabled(true);
    this.emit('videoOn');
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.isAudioEnabled" id="apidoc.element.webrtc.super_.prototype.isAudioEnabled">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>isAudioEnabled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAudioEnabled = function () {
    var enabled = true;
    this.localStreams.forEach(function (stream) {
        stream.getAudioTracks().forEach(function (track) {
            enabled = enabled &amp;&amp; track.enabled;
        });
    });
    return enabled;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.isVideoEnabled" id="apidoc.element.webrtc.super_.prototype.isVideoEnabled">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>isVideoEnabled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isVideoEnabled = function () {
    var enabled = true;
    this.localStreams.forEach(function (stream) {
        stream.getVideoTracks().forEach(function (track) {
            enabled = enabled &amp;&amp; track.enabled;
        });
    });
    return enabled;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.mute" id="apidoc.element.webrtc.super_.prototype.mute">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>mute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mute = function () {
    this._audioEnabled(false);
    this.hardMuted = true;
    this.emit('audioOff');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
LocalMedia.prototype.resumeVideo = function () {
    this._videoEnabled(true);
    this.emit('videoOn');
};

// Combined controls
LocalMedia.prototype.pause = function () {
    this.<span class="apidocCodeKeywordSpan">mute</span>();
    this.pauseVideo();
};
LocalMedia.prototype.resume = function () {
    this.unmute();
    this.resumeVideo();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.pause" id="apidoc.element.webrtc.super_.prototype.pause">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
    this.mute();
    this.pauseVideo();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.pauseVideo" id="apidoc.element.webrtc.super_.prototype.pauseVideo">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>pauseVideo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pauseVideo = function () {
    this._videoEnabled(false);
    this.emit('videoOff');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._videoEnabled(true);
    this.emit('videoOn');
};

// Combined controls
LocalMedia.prototype.pause = function () {
    this.mute();
    this.<span class="apidocCodeKeywordSpan">pauseVideo</span>();
};
LocalMedia.prototype.resume = function () {
    this.unmute();
    this.resumeVideo();
};

// Internal methods for enabling/disabling audio/video
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.resume" id="apidoc.element.webrtc.super_.prototype.resume">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
    this.unmute();
    this.resumeVideo();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.resumeVideo" id="apidoc.element.webrtc.super_.prototype.resumeVideo">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>resumeVideo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resumeVideo = function () {
    this._videoEnabled(true);
    this.emit('videoOn');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Combined controls
LocalMedia.prototype.pause = function () {
this.mute();
this.pauseVideo();
};
LocalMedia.prototype.resume = function () {
this.unmute();
this.<span class="apidocCodeKeywordSpan">resumeVideo</span>();
};

// Internal methods for enabling/disabling audio/video
LocalMedia.prototype._audioEnabled = function (bool) {
// work around for chrome 27 bug where disabling tracks
// doesn't seem to work (works in canary, remove when working)
this.setMicIfEnabled(bool ? 1 : 0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.setMicIfEnabled" id="apidoc.element.webrtc.super_.prototype.setMicIfEnabled">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>setMicIfEnabled
        <span class="apidocSignatureSpan">(volume)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMicIfEnabled = function (volume) {
    if (!this.config.autoAdjustMic) {
        return;
    }
    this.gainController.setGain(volume);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self.setupAudioMonitor(stream, self.config.harkOptions);
}
self.localStreams.push(stream);

if (self.config.autoAdjustMic) {
    self.gainController = new GainController(stream);
    // start out somewhat muted if we can track audio
    self.<span class="apidocCodeKeywordSpan">setMicIfEnabled</span>(0.5);
}

// TODO: might need to migrate to the video tracks onended
// FIXME: firefox does not seem to trigger this...
stream.onended = function () {
    /*
    var idx = self.localStreams.indexOf(stream);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.setupAudioMonitor" id="apidoc.element.webrtc.super_.prototype.setupAudioMonitor">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>setupAudioMonitor
        <span class="apidocSignatureSpan">(stream, harkOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupAudioMonitor = function (stream, harkOptions) {
    this._log('Setup audio');
    var audio = this.audioMonitor = hark(stream, harkOptions);
    var self = this;
    var timeout;

    audio.on('speaking', function () {
        self.emit('speaking');
        if (self.hardMuted) {
            return;
        }
        self.setMicIfEnabled(1);
    });

    audio.on('stopped_speaking', function () {
        if (timeout) {
            clearTimeout(timeout);
        }

        timeout = setTimeout(function () {
            self.emit('stoppedSpeaking');
            if (self.hardMuted) {
                return;
            }
            self.setMicIfEnabled(0.5);
        }, 1000);
    });
    audio.on('volume_change', function (volume, treshold) {
        self.emit('volumeChange', volume, treshold);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
LocalMedia.prototype.start = function (mediaConstraints, cb) {
    var self = this;
    var constraints = mediaConstraints || this.config.media;

    getUserMedia(constraints, function (err, stream) {
        if (!err) {
if (constraints.audio &amp;&amp; self.config.detectSpeakingEvents) {
    self.<span class="apidocCodeKeywordSpan">setupAudioMonitor</span>(stream, self.config.harkOptions);
}
self.localStreams.push(stream);

if (self.config.autoAdjustMic) {
    self.gainController = new GainController(stream);
    // start out somewhat muted if we can track audio
    self.setMicIfEnabled(0.5);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.start" id="apidoc.element.webrtc.super_.prototype.start">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>start
        <span class="apidocSignatureSpan">(mediaConstraints, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (mediaConstraints, cb) {
    var self = this;
    var constraints = mediaConstraints || this.config.media;

    getUserMedia(constraints, function (err, stream) {

        if (!err) {
            if (constraints.audio &amp;&amp; self.config.detectSpeakingEvents) {
                self.setupAudioMonitor(stream, self.config.harkOptions);
            }
            self.localStreams.push(stream);

            if (self.config.autoAdjustMic) {
                self.gainController = new GainController(stream);
                // start out somewhat muted if we can track audio
                self.setMicIfEnabled(0.5);
            }

            // TODO: might need to migrate to the video tracks onended
            // FIXME: firefox does not seem to trigger this...
            stream.onended = function () {
<span class="apidocCodeCommentSpan">                /*
                var idx = self.localStreams.indexOf(stream);
                if (idx &gt; -1) {
                    self.localScreens.splice(idx, 1);
                }
                self.emit('localStreamStopped', stream);
                */
</span>            };

            self.emit('localStream', stream);
        } else {
            // Fallback for users without a camera
            if (self.config.audioFallback &amp;&amp; err.name === 'DevicesNotFoundError' &amp;&amp; constraints.video !== false) {
                constraints.video = false;
                self.start(constraints, cb);
                return;
            }
        }
        if (cb) {
            return cb(err, stream);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        peer1.pc.on('iceConnectionStateChange', function () {
            if (peer1.pc.iceConnectionState == 'connected') {
                t.pass('P2P connection established');
                t.end();
            }
        });

        peer1.<span class="apidocCodeKeywordSpan">start</span>();
    });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.startLocalMedia" id="apidoc.element.webrtc.super_.prototype.startLocalMedia">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>startLocalMedia
        <span class="apidocSignatureSpan">(mediaConstraints, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startLocalMedia = function (mediaConstraints, cb) {
    var self = this;
    var constraints = mediaConstraints || this.config.media;

    getUserMedia(constraints, function (err, stream) {

        if (!err) {
            if (constraints.audio &amp;&amp; self.config.detectSpeakingEvents) {
                self.setupAudioMonitor(stream, self.config.harkOptions);
            }
            self.localStreams.push(stream);

            if (self.config.autoAdjustMic) {
                self.gainController = new GainController(stream);
                // start out somewhat muted if we can track audio
                self.setMicIfEnabled(0.5);
            }

            // TODO: might need to migrate to the video tracks onended
            // FIXME: firefox does not seem to trigger this...
            stream.onended = function () {
<span class="apidocCodeCommentSpan">                /*
                var idx = self.localStreams.indexOf(stream);
                if (idx &gt; -1) {
                    self.localScreens.splice(idx, 1);
                }
                self.emit('localStreamStopped', stream);
                */
</span>            };

            self.emit('localStream', stream);
        } else {
            // Fallback for users without a camera
            if (self.config.audioFallback &amp;&amp; err.name === 'DevicesNotFoundError' &amp;&amp; constraints.video !== false) {
                constraints.video = false;
                self.start(constraints, cb);
                return;
            }
        }
        if (cb) {
            return cb(err, stream);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    webrtc1.on('message', function (payload) {
peer2.handleMessage(payload);
    });
    webrtc2.on('message', function (payload) {
peer1.handleMessage(payload);
    });
    webrtc1.<span class="apidocCodeKeywordSpan">startLocalMedia</span>(null, function (err, stream) {
if (err) {
    t.fail('failed to get local media');
    return;
}
t.pass('got local media');

webrtc2.localStream = stream;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.startScreenShare" id="apidoc.element.webrtc.super_.prototype.startScreenShare">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>startScreenShare
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startScreenShare = function (cb) {
    var self = this;
    getScreenMedia(function (err, stream) {
        if (!err) {
            self.localScreens.push(stream);

            // TODO: might need to migrate to the video tracks onended
            // Firefox does not support .onended but it does not support
            // screensharing either
            stream.onended = function () {
                var idx = self.localScreens.indexOf(stream);
                if (idx &gt; -1) {
                    self.localScreens.splice(idx, 1);
                }
                self.emit('localScreenStopped', stream);
            };
            self.emit('localScreen', stream);
        }

        // enable the callback
        if (cb) {
            return cb(err, stream);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.stop" id="apidoc.element.webrtc.super_.prototype.stop">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>stop
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (stream) {
    var self = this;
    // FIXME: duplicates cleanup code until fixed in FF
    if (stream) {
        stream.getTracks().forEach(function (track) { track.stop(); });
        var idx = self.localStreams.indexOf(stream);
        if (idx &gt; -1) {
            self.emit('localStreamStopped', stream);
            self.localStreams = self.localStreams.splice(idx, 1);
        } else {
            idx = self.localScreens.indexOf(stream);
            if (idx &gt; -1) {
                self.emit('localScreenStopped', stream);
                self.localScreens = self.localScreens.splice(idx, 1);
            }
        }
    } else {
        this.stopStreams();
        this.stopScreenShare();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
};

LocalMedia.prototype.stop = function (stream) {
var self = this;
// FIXME: duplicates cleanup code until fixed in FF
if (stream) {
    stream.<span class="apidocCodeKeywordSpan">stop</span>();
    self.emit('localStreamStopped', stream);
    var idx = self.localStreams.indexOf(stream);
    if (idx &gt; -1) {
        self.localStreams = self.localStreams.splice(idx, 1);
    }
} else {
    if (this.audioMonitor) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.stopLocalMedia" id="apidoc.element.webrtc.super_.prototype.stopLocalMedia">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>stopLocalMedia
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopLocalMedia = function (stream) {
    var self = this;
    // FIXME: duplicates cleanup code until fixed in FF
    if (stream) {
        stream.getTracks().forEach(function (track) { track.stop(); });
        var idx = self.localStreams.indexOf(stream);
        if (idx &gt; -1) {
            self.emit('localStreamStopped', stream);
            self.localStreams = self.localStreams.splice(idx, 1);
        } else {
            idx = self.localScreens.indexOf(stream);
            if (idx &gt; -1) {
                self.emit('localScreenStopped', stream);
                self.localScreens = self.localScreens.splice(idx, 1);
            }
        }
    } else {
        this.stopStreams();
        this.stopScreenShare();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.stopScreenShare" id="apidoc.element.webrtc.super_.prototype.stopScreenShare">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>stopScreenShare
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopScreenShare = function (stream) {
    var self = this;
    if (stream) {
        stream.getTracks().forEach(function (track) { track.stop(); });
        this.emit('localScreenStopped', stream);
    } else {
        this.localScreens.forEach(function (stream) {
            stream.getTracks().forEach(function (track) { track.stop(); });
            self.emit('localScreenStopped', stream);
        });
        this.localScreens = [];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.stopStreams" id="apidoc.element.webrtc.super_.prototype.stopStreams">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>stopStreams
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopStreams = function () {
    var self = this;
    if (this.audioMonitor) {
        this.audioMonitor.stop();
        delete this.audioMonitor;
    }
    this.localStreams.forEach(function (stream) {
        stream.getTracks().forEach(function (track) { track.stop(); });
        self.emit('localStreamStopped', stream);
    });
    this.localStreams = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.prototype.unmute" id="apidoc.element.webrtc.super_.prototype.unmute">
        function <span class="apidocSignatureSpan">webrtc.super_.prototype.</span>unmute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmute = function () {
    this._audioEnabled(true);
    this.hardMuted = false;
    this.emit('audioOn');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Combined controls
LocalMedia.prototype.pause = function () {
this.mute();
this.pauseVideo();
};
LocalMedia.prototype.resume = function () {
this.<span class="apidocCodeKeywordSpan">unmute</span>();
this.resumeVideo();
};

// Internal methods for enabling/disabling audio/video
LocalMedia.prototype._audioEnabled = function (bool) {
// work around for chrome 27 bug where disabling tracks
// doesn't seem to work (works in canary, remove when working)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webrtc.super_.super_" id="apidoc.module.webrtc.super_.super_">module webrtc.super_.super_</a></h1>


    <h2>
        <a href="#apidoc.element.webrtc.super_.super_.super_" id="apidoc.element.webrtc.super_.super_.super_">
        function <span class="apidocSignatureSpan">webrtc.super_.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WildEmitter() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.super_.mixin" id="apidoc.element.webrtc.super_.super_.mixin">
        function <span class="apidocSignatureSpan">webrtc.super_.super_.</span>mixin
        <span class="apidocSignatureSpan">(constructor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (constructor) {
    var prototype = constructor.prototype || constructor;

    prototype.isWildEmitter= true;

    // Listen on the given `event` with `fn`. Store a group name if present.
    prototype.on = function (event, groupName, fn) {
        this.callbacks = this.callbacks || {};
        var hasGroup = (arguments.length === 3),
            group = hasGroup ? arguments[1] : undefined,
            func = hasGroup ? arguments[2] : arguments[1];
        func._groupName = group;
        (this.callbacks[event] = this.callbacks[event] || []).push(func);
        return this;
    };

    // Adds an `event` listener that will be invoked a single
    // time then automatically removed.
    prototype.once = function (event, groupName, fn) {
        var self = this,
            hasGroup = (arguments.length === 3),
            group = hasGroup ? arguments[1] : undefined,
            func = hasGroup ? arguments[2] : arguments[1];
        function on() {
            self.off(event, on);
            func.apply(this, arguments);
        }
        this.on(event, group, on);
        return this;
    };

    // Unbinds an entire group
    prototype.releaseGroup = function (groupName) {
        this.callbacks = this.callbacks || {};
        var item, i, len, handlers;
        for (item in this.callbacks) {
            handlers = this.callbacks[item];
            for (i = 0, len = handlers.length; i &lt; len; i++) {
                if (handlers[i]._groupName === groupName) {
                    //console.log('removing');
                    // remove it and shorten the array we're looping through
                    handlers.splice(i, 1);
                    i--;
                    len--;
                }
            }
        }
        return this;
    };

    // Remove the given callback for `event` or all
    // registered callbacks.
    prototype.off = function (event, fn) {
        this.callbacks = this.callbacks || {};
        var callbacks = this.callbacks[event],
            i;

        if (!callbacks) return this;

        // remove all handlers
        if (arguments.length === 1) {
            delete this.callbacks[event];
            return this;
        }

        // remove specific handler
        i = callbacks.indexOf(fn);
        callbacks.splice(i, 1);
        if (callbacks.length === 0) {
            delete this.callbacks[event];
        }
        return this;
    };

    /// Emit `event` with the given args.
    // also calls any `*` handlers
    prototype.emit = function (event) {
        this.callbacks = this.callbacks || {};
        var args = [].slice.call(arguments, 1),
            callbacks = this.callbacks[event],
            specialCallbacks = this.getWildcardCallbacks(event),
            i,
            len,
            item,
            listeners;

        if (callbacks) {
            listeners = callbacks.slice();
            for (i = 0, len = listeners.length; i &lt; len; ++i) {
                if (!listeners[i]) {
                    break;
                }
                listeners[i].apply(this, args);
            }
        }

        if (specialCallbacks) {
            len = specialCallbacks.length;
            listeners = specialCallbacks.slice();
            for (i = 0, len = listeners.length; i &lt; len; ++i) {
                if (!listeners[i]) {
                    break;
                }
                listeners[i].apply(this, [event].concat(args));
            }
        }

        return this;
    };

    // Helper for for finding special wildcard event handlers that match the event
    prototype.getWildcardCallbacks = function (eventName) {
        this.callbacks = this.callbacks || {};
        var item,
            split,
            result = [];

        for (item in this.callbacks) {
            split = item.split('*');
            if (item === '*' || (split.length === 2 &amp;&amp; eventName.slice(0, split[0].length) === split[0])) {
                result = result.concat(this.c ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      push.apply(args, arguments);
      return result(this, func.apply(_, args));
    };
  });
};

// Add all of the Underscore functions to the wrapper object.
_.<span class="apidocCodeKeywordSpan">mixin</span>(_);

// Add all mutator Array functions to the wrapper.
_.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift
'], function(name) {
  var method = ArrayProto[name];
  _.prototype[name] = function() {
    var obj = this._wrapped;
    method.apply(obj, arguments);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webrtc.super_.super_.prototype" id="apidoc.module.webrtc.super_.super_.prototype">module webrtc.super_.super_.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.webrtc.super_.super_.prototype.emit" id="apidoc.element.webrtc.super_.super_.prototype.emit">
        function <span class="apidocSignatureSpan">webrtc.super_.super_.prototype.</span>emit
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (event) {
    this.callbacks = this.callbacks || {};
    var args = [].slice.call(arguments, 1),
        callbacks = this.callbacks[event],
        specialCallbacks = this.getWildcardCallbacks(event),
        i,
        len,
        item,
        listeners;

    if (callbacks) {
        listeners = callbacks.slice();
        for (i = 0, len = listeners.length; i &lt; len; ++i) {
            if (!listeners[i]) {
                break;
            }
            listeners[i].apply(this, args);
        }
    }

    if (specialCallbacks) {
        len = specialCallbacks.length;
        listeners = specialCallbacks.slice();
        for (i = 0, len = listeners.length; i &lt; len; ++i) {
            if (!listeners[i]) {
                break;
            }
            listeners[i].apply(this, [event].concat(args));
        }
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
+
     // Actually generate the offer
     this.pc.createOffer(
         function (offer) {
+            // does not work for jingle, but jingle.js doesn't need
+            // this hack...
+            if (self.assumeSetLocalSuccess) {
+                self.<span class="apidocCodeKeywordSpan">emit</span>('offer', offer);
+                cb(null, offer);
+            }
             self.pc.setLocalDescription(offer,
                 function () {
var jingle;
@@ -3463,7 +3508,7 @@ PeerConnection.prototype.offer = function (constraints, cb) {
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.super_.prototype.getWildcardCallbacks" id="apidoc.element.webrtc.super_.super_.prototype.getWildcardCallbacks">
        function <span class="apidocSignatureSpan">webrtc.super_.super_.prototype.</span>getWildcardCallbacks
        <span class="apidocSignatureSpan">(eventName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getWildcardCallbacks = function (eventName) {
    this.callbacks = this.callbacks || {};
    var item,
        split,
        result = [];

    for (item in this.callbacks) {
        split = item.split('*');
        if (item === '*' || (split.length === 2 &amp;&amp; eventName.slice(0, split[0].length) === split[0])) {
            result = result.concat(this.callbacks[item]);
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/// Emit `event` with the given args.
// also calls any `*` handlers
WildEmitter.prototype.emit = function (event) {
var args = [].slice.call(arguments, 1),
    callbacks = this.callbacks[event],
    specialCallbacks = this.<span class="apidocCodeKeywordSpan">getWildcardCallbacks</span>(event),
    i,
    len,
    item,
    listeners;

if (callbacks) {
    listeners = callbacks.slice();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.super_.prototype.off" id="apidoc.element.webrtc.super_.super_.prototype.off">
        function <span class="apidocSignatureSpan">webrtc.super_.super_.prototype.</span>off
        <span class="apidocSignatureSpan">(event, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function (event, fn) {
    this.callbacks = this.callbacks || {};
    var callbacks = this.callbacks[event],
        i;

    if (!callbacks) return this;

    // remove all handlers
    if (arguments.length === 1) {
        delete this.callbacks[event];
        return this;
    }

    // remove specific handler
    i = callbacks.indexOf(fn);
    callbacks.splice(i, 1);
    if (callbacks.length === 0) {
        delete this.callbacks[event];
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// time then automatically removed.
WildEmitter.prototype.once = function (event, groupName, fn) {
    var self = this,
        hasGroup = (arguments.length === 3),
        group = hasGroup ? arguments[1] : undefined,
        func = hasGroup ? arguments[2] : arguments[1];
    function on() {
        self.<span class="apidocCodeKeywordSpan">off</span>(event, on);
        func.apply(this, arguments);
    }
    this.on(event, group, on);
    return this;
};

// Unbinds an entire group
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.super_.prototype.on" id="apidoc.element.webrtc.super_.super_.prototype.on">
        function <span class="apidocSignatureSpan">webrtc.super_.super_.prototype.</span>on
        <span class="apidocSignatureSpan">(event, groupName, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (event, groupName, fn) {
    this.callbacks = this.callbacks || {};
    var hasGroup = (arguments.length === 3),
        group = hasGroup ? arguments[1] : undefined,
        func = hasGroup ? arguments[2] : arguments[1];
    func._groupName = group;
    (this.callbacks[event] = this.callbacks[event] || []).push(func);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
@@ -3313,8 +3344,6 @@ function PeerConnection(config, constraints) {
         this.config[item] = config[item];
     }

-    this._role = this.isInitiator ? 'initiator' : 'responder';
-
     if (this.config.debug) {
         this.<span class="apidocCodeKeywordSpan">on</span>('*', function (eventName, event) {
             var logger = config.logger || console;
@@ -3352,6 +3381,10 @@ Object.defineProperty(PeerConnection.prototype, 'iceConnectionState', {
     }
 });

+PeerConnection.prototype._role = function () {
+    return this.isInitiator ? 'initiator' : 'responder';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.super_.prototype.once" id="apidoc.element.webrtc.super_.super_.prototype.once">
        function <span class="apidocSignatureSpan">webrtc.super_.super_.prototype.</span>once
        <span class="apidocSignatureSpan">(event, groupName, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (event, groupName, fn) {
    var self = this,
        hasGroup = (arguments.length === 3),
        group = hasGroup ? arguments[1] : undefined,
        func = hasGroup ? arguments[2] : arguments[1];
    function on() {
        self.off(event, on);
        func.apply(this, arguments);
    }
    this.on(event, group, on);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webrtc.super_.super_.prototype.releaseGroup" id="apidoc.element.webrtc.super_.super_.prototype.releaseGroup">
        function <span class="apidocSignatureSpan">webrtc.super_.super_.prototype.</span>releaseGroup
        <span class="apidocSignatureSpan">(groupName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">releaseGroup = function (groupName) {
    this.callbacks = this.callbacks || {};
    var item, i, len, handlers;
    for (item in this.callbacks) {
        handlers = this.callbacks[item];
        for (i = 0, len = handlers.length; i &lt; len; i++) {
            if (handlers[i]._groupName === groupName) {
                //console.log('removing');
                // remove it and shorten the array we're looping through
                handlers.splice(i, 1);
                i--;
                len--;
            }
        }
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>